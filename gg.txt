# bot_collect.py — scan WIN+PLACE, logs verbeux par chunk, fallback DSC-0018,
# switch ENV INCLUDE_SP_IN_BOOK, latences, et passage à Executor pour snapshots.

from __future__ import annotations
import os, time, sys
from datetime import datetime, timedelta, timezone
from typing import List, Iterable, Tuple, Any

from dotenv import load_dotenv
from betfairlightweight import APIClient
from betfairlightweight.filters import market_filter, price_projection, ex_best_offers_overrides
from betfairlightweight.exceptions import APIError

from src.dogbot.indexer import MarketIndex  # type: ignore
from src.dogbot.strategy.back_win_1 import BackWin1
from src.dogbot.executor import Executor

# ---------- helpers ----------
def _env_int(name: str, default: int) -> int:
    try:
        return int((os.environ.get(name) or "").strip() or default)
    except Exception:
        return int(default)

def _env_float(name: str, default: float) -> float:
    try:
        return float((os.environ.get(name) or "").strip() or default)
    except Exception:
        return float(default)

def _env_bool(name: str, default: bool) -> bool:
    val = (os.environ.get(name) or "").strip().lower()
    if val in ("1","true","yes","y","on"): return True
    if val in ("0","false","no","n","off"): return False
    return bool(default)

def _now_utc_iso() -> str:
    return datetime.now(timezone.utc).isoformat().replace("+00:00", "Z")

def _chunked(seq: List[str], n: int) -> List[List[str]]:
    return [seq[i:i+n] for i in range(0, len(seq), n)]

def _mindex_pairs(mindex: Any) -> Iterable[Tuple[str | None, Any]]:
    """Itère sur MarketIndex quelle que soit son implémentation."""
    try:
        for k, v in mindex.items():  # type: ignore[attr-defined]
            yield (str(k) if k is not None else None), v
        return
    except Exception:
        pass
    try:
        for v in mindex.values():  # type: ignore[attr-defined]
            mid = getattr(v, "market_id", None) or getattr(v, "marketId", None)
            yield (str(mid) if mid is not None else None), v
        return
    except Exception:
        pass
    try:
        for v in mindex:
            mid = getattr(v, "market_id", None) or getattr(v, "marketId", None)
            yield (str(mid) if mid is not None else None), v
        return
    except Exception:
        pass
    for attr in ("by_id", "_by_id", "map", "_map", "d", "_d"):
        d = getattr(mindex, attr, None)
        if isinstance(d, dict):
            for k, v in d.items():
                yield (str(k) if k is not None else None), v
            return
    return []

# ---------- price projections ----------
PP_NOSP = price_projection(
    price_data=["EX_BEST_OFFERS"],
    ex_best_offers_overrides=ex_best_offers_overrides(best_prices_depth=3),
    virtualise=True,
    rollover_stakes=False,
)
PP_FULL = price_projection(
    price_data=["EX_BEST_OFFERS", "SP_AVAILABLE"],  # SP estimé (near/far)
    ex_best_offers_overrides=ex_best_offers_overrides(best_prices_depth=3),
    virtualise=True,
    rollover_stakes=False,
)
PP_MIN = price_projection(
    price_data=["EX_LTP"],  # fallback léger si DSC-0018
    virtualise=True,
    rollover_stakes=False,
)

# ---------- catalogue ----------
def fetch_catalogue(client: APIClient, lookahead_minutes: int, max_markets: int):
    now = datetime.now(timezone.utc)
    to  = now + timedelta(minutes=lookahead_minutes)
    mf = market_filter(
        event_type_ids=["4339"],              # Greyhound Racing
        market_type_codes=["WIN", "PLACE"],   # inclut PLACE pour le lien
        market_start_time={"from": now.isoformat().replace("+00:00","Z"),
                           "to":   to.isoformat().replace("+00:00","Z")},
    )
    cats = client.betting.list_market_catalogue(
        filter=mf,
        market_projection=["EVENT","MARKET_START_TIME","RUNNER_DESCRIPTION","RUNNER_METADATA"],
        sort="FIRST_TO_START",
        max_results=max_markets
    )
    return cats

def build_market_index(cats) -> MarketIndex:
    try:
        return MarketIndex(cats)  # type: ignore
    except TypeError:
        mi = MarketIndex([])      # type: ignore
        try:
            mi.ingest(cats)
        except Exception:
            pass
        return mi

# ---------- main ----------
def main():
    load_dotenv()

    # Conseillé pour des logs instantanés: python -u ou PYTHONUNBUFFERED=1
    if not os.environ.get("PYTHONUNBUFFERED"):
        try:
            sys.stdout.reconfigure(line_buffering=True)  # type: ignore[attr-defined]
        except Exception:
            pass

    user  = os.environ.get("BF_USER")
    pwd   = os.environ.get("BF_PASS")
    appk  = os.environ.get("BF_APP_KEY")
    certs = os.environ.get("BF_CERTS_PATH")
    if not (user and pwd and appk and certs):
        print("Manque des variables d'env (BF_USER/BF_PASS/BF_APP_KEY/BF_CERTS_PATH)")
        return

    LOOKAHEAD_MINUTES = _env_int("LOOKAHEAD_MINUTES", 60)
    SCAN_EVERY_S      = _env_int("SCAN_EVERY_S", 60)
    POLL_INTERVAL_S   = _env_float("POLL_INTERVAL_S", 2.0)
    BATCH_SIZE        = _env_int("BATCH_SIZE", 5)
    MAX_MARKETS       = _env_int("MAX_MARKETS", 25)
    INCLUDE_SP        = _env_bool("INCLUDE_SP_IN_BOOK", True)

    print(f"[BOOT] {_now_utc_iso()}  lookahead={LOOKAHEAD_MINUTES}m scan_every={SCAN_EVERY_S}s poll={POLL_INTERVAL_S}s batch={BATCH_SIZE} max_markets={MAX_MARKETS} include_sp={INCLUDE_SP}")

    client = APIClient(username=user, password=pwd, app_key=appk, certs=certs)
    print("[LOGIN] connecting...")
    client.login()
    print("[LOGIN] OK")

    print("[CATALOGUE] fetching...")
    cats = fetch_catalogue(client, LOOKAHEAD_MINUTES, MAX_MARKETS)
    print(f"[CATALOGUE] found {len(cats)} markets")
    mindex = build_market_index(cats)

    strat = BackWin1()
    execu = Executor(client=client, strategy=strat, market_index=mindex, dry_run=True, data_dir="./data")

    last_scan_ts = time.time()
    last_keep_alive = time.time()

    try:
        while True:
            now_ts = time.time()

            # keep-alive périodique
            if now_ts - last_keep_alive > 540:
                t0 = time.time()
                try:
                    client.keep_alive()
                    print(f"[KEEP-ALIVE] OK ({int((time.time()-t0)*1000)} ms)")
                except Exception as e:
                    print("[KEEP-ALIVE] error:", e)
                last_keep_alive = now_ts

            # refresh catalogue périodique
            if now_ts - last_scan_ts >= SCAN_EVERY_S:
                try:
                    print("[CATALOGUE] refresh...")
                    t0 = time.time()
                    cats = fetch_catalogue(client, LOOKAHEAD_MINUTES, MAX_MARKETS)
                    print(f"[CATALOGUE] refresh done: {len(cats)} markets ({int((time.time()-t0)*1000)} ms)")
                    mindex = build_market_index(cats)
                    execu.market_index = mindex
                except Exception as e:
                    print("[CATALOGUE] refresh error:", e)
                last_scan_ts = now_ts

            # Liste des marketIds à requêter
            market_ids: List[str] = []
            for k, mie in _mindex_pairs(mindex):
                mid = getattr(mie, "market_id", None) or k
                if mid:
                    market_ids.append(str(mid))
                if len(market_ids) >= MAX_MARKETS:
                    break

            if not market_ids:
                time.sleep(POLL_INTERVAL_S)
                continue

            chunks = _chunked(market_ids, max(1, BATCH_SIZE))
            total_chunks = len(chunks)
            print(f"[LOOP] polling books for {len(market_ids)} markets in {total_chunks} chunks (batch={BATCH_SIZE})")

            # Pull des books par paquets + logs
            for ci, chunk in enumerate(chunks, start=1):
                proj = PP_FULL if INCLUDE_SP else PP_NOSP
                print(f"[BOOKS] chunk {ci}/{total_chunks} start: {len(chunk)} ids -> {chunk}")
                t0 = time.time()
                try:
                    books = client.betting.list_market_book(
                        market_ids=chunk,
                        price_projection=proj,
                    )
                    elapsed = int((time.time() - t0) * 1000)
                    print(f"[BOOKS] chunk {ci}/{total_chunks} got {len(books)} books in {elapsed} ms")
                except APIError as e:
                    if "DSC-0018" in str(e):
                        print(f"[BOOKS] chunk {ci}/{total_chunks} payload too big -> fallback EX_LTP")
                        t1 = time.time()
                        books = client.betting.list_market_book(
                            market_ids=chunk,
                            price_projection=PP_MIN,
                        )
                        elapsed = int((time.time() - t1) * 1000)
                        print(f"[BOOKS] chunk {ci}/{total_chunks} (fallback) got {len(books)} books in {elapsed} ms")
                    else:
                        print(f"[BOOKS] chunk {ci}/{total_chunks} APIError: {e}")
                        continue

                # pousse vers l’exécuteur
                for b in (books or []):
                    try:
                        execu.process_book(b)
                    except Exception as e:
                        mid = getattr(b, "market_id", "?")
                        print(f"[EXECUTOR_ERR] {mid}: {e}")

                # petit rythme
                time.sleep(POLL_INTERVAL_S)

    finally:
        try:
            client.logout()
            print("[LOGOUT] OK")
        except Exception:
            pass

if __name__ == "__main__":
    main()
